<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agent Sessions</title>
    <style>
        :root {
            --bg: #0d1117;
            --surface: #161b22;
            --surface-hover: #21262d;
            --border: #30363d;
            --text: #e6edf3;
            --text-muted: #8b949e;
            --accent: #58a6ff;
            --accent-muted: #388bfd;
            --user-bg: #1c2128;
            --assistant-bg: #1a1f26;
            --success: #3fb950;
            --warning: #d29922;
            --tool-bg: #1a2332;
            --thinking-bg: #1f1a24;
            --agent-accent: #9d7cd8;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Mono', Monaco, monospace;
            background: var(--bg);
            color: var(--text);
            line-height: 1.5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 16px;
        }

        header {
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            padding: 12px 0;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        h1 {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text);
        }

        .search-box {
            flex: 1;
            max-width: 500px;
            position: relative;
        }

        .search-box input {
            width: 100%;
            padding: 8px 12px 8px 36px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 0.9rem;
        }

        .search-box input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .search-icon {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-muted);
        }

        .header-actions {
            display: flex;
            gap: 8px;
        }

        .btn {
            padding: 6px 12px;
            background: var(--surface-hover);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            cursor: pointer;
            font-size: 0.85rem;
        }

        .btn:hover { background: var(--border); }

        main {
            display: flex;
            min-height: calc(100vh - 60px);
        }

        .sidebar {
            width: 320px;
            border-right: 1px solid var(--border);
            overflow-y: auto;
            height: calc(100vh - 60px);
            position: sticky;
            top: 60px;
        }

        .sidebar-header {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sidebar-header h2 {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .session-list { list-style: none; }

        .session-item {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
        }

        .session-item:hover { background: var(--surface); }
        .session-item.active { background: var(--surface-hover); border-left: 3px solid var(--accent); }

        .session-project {
            font-size: 0.75rem;
            color: var(--accent);
            margin-bottom: 2px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .session-title {
            font-size: 0.9rem;
            color: var(--text);
            margin-bottom: 4px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .session-meta {
            font-size: 0.75rem;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .session-meta .meta-sep { opacity: 0.5; }
        .session-meta .agent-name { color: #d4a574; }
        .session-meta .agent-name.codex { color: #7dd3fc; }

        .badge {
            background: var(--surface-hover);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7rem;
        }

        .content {
            flex: 1;
            padding: 24px;
            padding-bottom: 60px;
            overflow-y: auto;
            height: calc(100vh - 60px);
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-muted);
        }

        .empty-state h2 {
            font-size: 1.25rem;
            margin-bottom: 8px;
            color: var(--text);
        }

        .messages {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .message {
            padding: 16px;
            border-radius: 8px;
            border: 1px solid var(--border);
            cursor: pointer;
            transition: border-color 0.15s, box-shadow 0.15s;
        }

        .message:hover { border-color: var(--text-muted); }
        .message.selected {
            border-color: var(--accent);
            box-shadow: 0 0 0 1px var(--accent);
        }

        .message.user {
            background: var(--user-bg);
            border-left: 3px solid var(--accent);
        }

        .message.assistant {
            background: var(--assistant-bg);
            border-left: 3px solid var(--agent-accent);
        }

        .message-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.8rem;
        }

        .message-role {
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .message.user .message-role { color: var(--accent); }
        .message.assistant .message-role { color: var(--agent-accent); }
        .message-time { color: var(--text-muted); }

        .message-content {
            white-space: pre-wrap;
            word-break: break-word;
            font-size: 0.9rem;
        }

        .message-content code {
            background: var(--bg);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: inherit;
            font-size: 0.85em;
        }

        .message-content pre {
            background: var(--bg);
            padding: 12px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 12px 0;
        }

        .message-content pre code {
            background: none;
            padding: 0;
        }

        .thinking-block {
            background: var(--thinking-bg);
            border-left: 2px solid #8b5cf6;
            padding: 12px;
            margin: 8px 0;
            border-radius: 4px;
            font-style: italic;
            color: var(--text-muted);
        }

        .thinking-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: #8b5cf6;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
            font-style: normal;
        }

        .tool-block {
            background: var(--tool-bg);
            border-left: 2px solid var(--warning);
            padding: 8px 12px;
            margin: 8px 0;
            border-radius: 4px;
            font-size: 0.85rem;
        }

        .search-results { padding: 16px; }

        .search-result {
            padding: 12px;
            background: var(--surface);
            border-radius: 6px;
            margin-bottom: 12px;
            cursor: pointer;
        }

        .search-result:hover { background: var(--surface-hover); }

        .search-result mark {
            background: var(--warning);
            color: var(--bg);
            padding: 0 2px;
            border-radius: 2px;
        }

        .search-result-meta {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-bottom: 6px;
        }

        .status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--surface);
            border-top: 1px solid var(--border);
            padding: 6px 16px;
            font-size: 0.75rem;
            color: var(--text-muted);
            display: flex;
            justify-content: space-between;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: var(--text-muted);
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal h2 {
            font-size: 1.1rem;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border);
        }

        .modal-close {
            float: right;
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        .modal-close:hover { color: var(--text); }

        .shortcut-list { list-style: none; }

        .shortcut-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid var(--border);
        }

        .shortcut-item:last-child { border-bottom: none; }

        .shortcut-keys { display: flex; gap: 4px; }

        .key {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 2px 8px;
            font-size: 0.8rem;
            min-width: 24px;
            text-align: center;
        }

        .shortcut-desc {
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        /* Virtual scroll container */
        .content-wrapper {
            position: relative;
            display: flex;
        }

        .messages-container {
            flex: 1;
            position: relative;
        }

        .messages {
            position: relative;
        }

        .message-spacer {
            flex-shrink: 0;
        }

        /* Minimap */
        .minimap {
            position: sticky;
            top: 0;
            right: 0;
            width: 80px;
            height: calc(100vh - 60px);
            background: var(--surface);
            border-left: 1px solid var(--border);
            flex-shrink: 0;
            cursor: pointer;
        }

        .minimap canvas {
            width: 100%;
            height: 100%;
        }

        .minimap-viewport {
            position: absolute;
            left: 0;
            right: 0;
            background: rgba(88, 166, 255, 0.2);
            border: 1px solid var(--accent);
            pointer-events: none;
        }

        .minimap-label {
            position: absolute;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
    </style>
</head>
<body>
    <header>
        <div class="container header-content">
            <h1>Agent Sessions</h1>
            <div class="search-box">
                <span class="search-icon">üîç</span>
                <input type="text" id="search-input" placeholder="Search messages...">
            </div>
            <div class="header-actions">
                <button class="btn" id="scroll-top-btn" title="Scroll to top">‚Üë Top</button>
                <button class="btn" id="sort-btn" title="Toggle message order">‚Üì Newest first</button>
                <button class="btn" id="sync-btn" title="Sync now">‚Üª Sync</button>
                <button class="btn" id="shortcuts-btn" title="Keyboard shortcuts">‚å® ?</button>
            </div>
        </div>
    </header>

    <main>
        <aside class="sidebar">
            <div class="sidebar-header">
                <h2>Sessions</h2>
                <span id="session-count" class="badge">0</span>
            </div>
            <ul class="session-list" id="session-list">
                <li class="loading"><span class="spinner"></span></li>
            </ul>
        </aside>

        <section class="content" id="content">
            <div class="empty-state">
                <h2>Select a session</h2>
                <p>Choose a session from the sidebar or search for messages</p>
            </div>
        </section>
    </main>

    <div class="status-bar">
        <span id="status-text">Loading...</span>
        <span id="sync-status"></span>
    </div>

    <div class="modal-overlay" id="shortcuts-modal">
        <div class="modal">
            <button class="modal-close" id="modal-close">&times;</button>
            <h2>Keyboard Shortcuts</h2>
            <ul class="shortcut-list">
                <li class="shortcut-item">
                    <span class="shortcut-desc">Focus search</span>
                    <span class="shortcut-keys"><span class="key">‚åò</span><span class="key">K</span></span>
                </li>
                <li class="shortcut-item">
                    <span class="shortcut-desc">Clear search / Close modal</span>
                    <span class="shortcut-keys"><span class="key">Esc</span></span>
                </li>
                <li class="shortcut-item">
                    <span class="shortcut-desc">Next message</span>
                    <span class="shortcut-keys"><span class="key">‚Üì</span> or <span class="key">J</span></span>
                </li>
                <li class="shortcut-item">
                    <span class="shortcut-desc">Previous message</span>
                    <span class="shortcut-keys"><span class="key">‚Üë</span> or <span class="key">K</span></span>
                </li>
                <li class="shortcut-item">
                    <span class="shortcut-desc">Next session</span>
                    <span class="shortcut-keys"><span class="key">]</span></span>
                </li>
                <li class="shortcut-item">
                    <span class="shortcut-desc">Previous session</span>
                    <span class="shortcut-keys"><span class="key">[</span></span>
                </li>
                <li class="shortcut-item">
                    <span class="shortcut-desc">Toggle message order</span>
                    <span class="shortcut-keys"><span class="key">O</span></span>
                </li>
                <li class="shortcut-item">
                    <span class="shortcut-desc">Sync sessions</span>
                    <span class="shortcut-keys"><span class="key">R</span></span>
                </li>
                <li class="shortcut-item">
                    <span class="shortcut-desc">Show shortcuts</span>
                    <span class="shortcut-keys"><span class="key">?</span></span>
                </li>
            </ul>
        </div>
    </div>

    <script>
        // Tauri API
        const { invoke } = window.__TAURI__.core;

        // State
        let sessions = [];
        let currentSession = null;
        let currentSessionData = null;
        let searchTimeout = null;
        let sortNewestFirst = true;
        let selectedMessageIndex = -1;
        let watchInterval = null;

        // Virtual scroll state
        let allMessages = [];           // All messages (sorted)
        let messageHeights = new Map(); // msg_id -> actual height
        let messageOffsets = [];        // Cumulative offsets for each message
        let totalHeight = 0;
        let visibleRange = { start: 0, end: 20 };
        const ESTIMATED_HEIGHT = 150;   // Default estimate per message
        const BUFFER_PX = 400;          // Render buffer above/below viewport
        const GAP = 16;                 // Gap between messages

        // DOM elements
        const sessionList = document.getElementById('session-list');
        const sessionCount = document.getElementById('session-count');
        const content = document.getElementById('content');
        const searchInput = document.getElementById('search-input');
        const syncBtn = document.getElementById('sync-btn');
        const sortBtn = document.getElementById('sort-btn');
        const scrollTopBtn = document.getElementById('scroll-top-btn');
        const shortcutsBtn = document.getElementById('shortcuts-btn');
        const shortcutsModal = document.getElementById('shortcuts-modal');
        const modalClose = document.getElementById('modal-close');
        const statusText = document.getElementById('status-text');
        const syncStatusEl = document.getElementById('sync-status');

        // API calls via Tauri invoke
        async function fetchSessions() {
            return await invoke('get_sessions', { limit: 1000 });
        }

        async function fetchMessages(sessionId) {
            return await invoke('get_messages', { sessionId });
        }

        async function searchMessages(query) {
            return await invoke('search', { query, limit: 50 });
        }

        async function triggerSync() {
            syncBtn.disabled = true;
            syncBtn.textContent = '‚Üª Syncing...';
            try {
                const stats = await invoke('trigger_sync');
                syncStatusEl.textContent = `Synced ${stats.synced} sessions`;
                await loadSessions();
            } finally {
                syncBtn.disabled = false;
                syncBtn.textContent = '‚Üª Sync';
            }
        }

        // Watch for session updates
        function startWatching(sessionId) {
            if (watchInterval) {
                clearInterval(watchInterval);
            }
            if (!sessionId) return;

            watchInterval = setInterval(async () => {
                try {
                    const updated = await invoke('check_session_update', { sessionId });
                    if (updated && currentSession && currentSession.session_id === sessionId) {
                        await invoke('sync_session', { sessionId });
                        const messages = await fetchMessages(sessionId);
                        currentSessionData = { session: currentSession, messages };
                        renderSession(currentSessionData);
                    }
                } catch (e) {
                    console.error('Watch error:', e);
                }
            }, 1500);
        }

        // Sort functions
        function toggleSort() {
            sortNewestFirst = !sortNewestFirst;
            sortBtn.textContent = sortNewestFirst ? '‚Üì Newest first' : '‚Üë Oldest first';
            if (currentSessionData) {
                renderSession(currentSessionData);
            }
        }

        // Render functions
        function renderSessionList() {
            sessionCount.textContent = sessions.length;
            sessionList.innerHTML = sessions.map(s => `
                <li class="session-item ${currentSession?.session_id === s.session_id ? 'active' : ''}"
                    data-id="${s.session_id}">
                    <div class="session-project">${escapeHtml(s.project || '')}</div>
                    <div class="session-title">${escapeHtml(s.first_message || 'No message')}</div>
                    <div class="session-meta">
                        <span class="agent-name ${s.agent || 'claude'}">${formatAgentName(s.agent)}</span>
                        <span class="meta-sep">¬∑</span>
                        <span>${s.message_count} msgs</span>
                        <span class="meta-sep">¬∑</span>
                        <span>${formatDate(s.started_at)}</span>
                    </div>
                </li>
            `).join('');

            sessionList.querySelectorAll('.session-item').forEach(item => {
                item.addEventListener('click', () => loadSession(item.dataset.id));
            });
        }

        // Calculate message offsets based on known or estimated heights
        function calculateOffsets() {
            messageOffsets = [];
            let offset = 0;
            for (let i = 0; i < allMessages.length; i++) {
                messageOffsets.push(offset);
                const height = messageHeights.get(allMessages[i].msg_id) || ESTIMATED_HEIGHT;
                offset += height + GAP;
            }
            totalHeight = offset - GAP; // Remove last gap
            return totalHeight;
        }

        // Find which messages are visible given scroll position
        function getVisibleRange(scrollTop, containerHeight) {
            if (allMessages.length === 0) return { start: 0, end: 0 };

            const viewStart = Math.max(0, scrollTop - BUFFER_PX);
            const viewEnd = scrollTop + containerHeight + BUFFER_PX;

            let start = 0;
            let end = allMessages.length;

            // Binary search for start
            let lo = 0, hi = allMessages.length - 1;
            while (lo <= hi) {
                const mid = Math.floor((lo + hi) / 2);
                const msgBottom = messageOffsets[mid] + (messageHeights.get(allMessages[mid].msg_id) || ESTIMATED_HEIGHT);
                if (msgBottom < viewStart) {
                    lo = mid + 1;
                } else {
                    hi = mid - 1;
                }
            }
            start = Math.max(0, lo - 1);

            // Binary search for end
            lo = start;
            hi = allMessages.length - 1;
            while (lo <= hi) {
                const mid = Math.floor((lo + hi) / 2);
                if (messageOffsets[mid] > viewEnd) {
                    hi = mid - 1;
                } else {
                    lo = mid + 1;
                }
            }
            end = Math.min(allMessages.length, hi + 2);

            return { start, end };
        }

        // Render only visible messages
        function renderVisibleMessages() {
            const messagesContainer = document.querySelector('.messages');
            if (!messagesContainer) return;

            const { start, end } = visibleRange;
            const topSpacer = start > 0 ? messageOffsets[start] : 0;
            const bottomSpacer = end < allMessages.length
                ? totalHeight - messageOffsets[end - 1] - (messageHeights.get(allMessages[end - 1]?.msg_id) || ESTIMATED_HEIGHT)
                : 0;

            let html = `<div class="message-spacer" style="height: ${topSpacer}px;"></div>`;

            for (let i = start; i < end && i < allMessages.length; i++) {
                const m = allMessages[i];
                html += `
                    <div class="message ${m.role} ${i === selectedMessageIndex ? 'selected' : ''}"
                         id="${m.msg_id}" data-index="${i}">
                        <div class="message-header">
                            <span class="message-role">${m.role}</span>
                            <span class="message-time">${formatTime(m.timestamp)}</span>
                        </div>
                        <div class="message-content">${formatContent(m.content)}</div>
                    </div>
                `;
            }

            html += `<div class="message-spacer" style="height: ${Math.max(0, bottomSpacer)}px;"></div>`;

            messagesContainer.innerHTML = html;

            // Measure rendered messages and update heights
            messagesContainer.querySelectorAll('.message').forEach(msg => {
                const id = msg.id;
                const height = msg.offsetHeight;
                if (height > 0 && messageHeights.get(id) !== height) {
                    messageHeights.set(id, height);
                }
                msg.addEventListener('click', () => {
                    selectMessage(parseInt(msg.dataset.index));
                });
            });
        }

        // Throttled scroll handler
        let scrollRaf = null;
        function handleScroll() {
            if (scrollRaf) return;
            scrollRaf = requestAnimationFrame(() => {
                scrollRaf = null;
                const scrollTop = content.scrollTop;
                const containerHeight = content.clientHeight;
                const newRange = getVisibleRange(scrollTop, containerHeight);

                if (newRange.start !== visibleRange.start || newRange.end !== visibleRange.end) {
                    visibleRange = newRange;
                    renderVisibleMessages();
                }

                updateMinimapViewport(scrollTop, containerHeight);
            });
        }

        // Render minimap
        function renderMinimap() {
            const minimap = document.querySelector('.minimap');
            if (!minimap || allMessages.length === 0) return;

            const canvas = minimap.querySelector('canvas');
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;

            // Set canvas size
            canvas.width = 80 * dpr;
            canvas.height = minimap.clientHeight * dpr;
            ctx.scale(dpr, dpr);

            const canvasHeight = minimap.clientHeight;
            const scale = canvasHeight / Math.max(totalHeight, 1);

            ctx.clearRect(0, 0, 80, canvasHeight);

            // Draw messages
            for (let i = 0; i < allMessages.length; i++) {
                const m = allMessages[i];
                const y = messageOffsets[i] * scale;
                const h = Math.max(2, (messageHeights.get(m.msg_id) || ESTIMATED_HEIGHT) * scale);

                ctx.fillStyle = m.role === 'user' ? '#58a6ff' : '#9d7cd8';
                ctx.fillRect(8, y, 64, h - 1);
            }
        }

        // Update minimap viewport indicator
        function updateMinimapViewport(scrollTop, containerHeight) {
            const viewport = document.querySelector('.minimap-viewport');
            if (!viewport || totalHeight === 0) return;

            const minimap = document.querySelector('.minimap');
            const canvasHeight = minimap.clientHeight;
            const scale = canvasHeight / Math.max(totalHeight, 1);

            const top = scrollTop * scale;
            const height = containerHeight * scale;

            viewport.style.top = `${top}px`;
            viewport.style.height = `${height}px`;
        }

        // Handle minimap click
        function handleMinimapClick(e) {
            const minimap = document.querySelector('.minimap');
            if (!minimap) return;

            const rect = minimap.getBoundingClientRect();
            const y = e.clientY - rect.top;
            const scale = minimap.clientHeight / Math.max(totalHeight, 1);
            const scrollTop = y / scale - content.clientHeight / 2;

            content.scrollTo({ top: Math.max(0, scrollTop) });
        }

        function renderSession(data) {
            const { session, messages } = data;
            allMessages = [...messages];
            if (sortNewestFirst) {
                allMessages.reverse();
            }
            selectedMessageIndex = -1;

            // Calculate initial offsets
            calculateOffsets();

            // Initial visible range
            visibleRange = getVisibleRange(0, content.clientHeight || 800);

            content.innerHTML = `
                <div class="content-wrapper">
                    <div class="messages-container">
                        <div class="messages" style="min-height: ${totalHeight}px;"></div>
                    </div>
                    <div class="minimap">
                        <canvas></canvas>
                        <div class="minimap-viewport"></div>
                    </div>
                </div>
            `;

            // Render visible messages
            renderVisibleMessages();

            // Setup scroll handler
            content.removeEventListener('scroll', handleScroll);
            content.addEventListener('scroll', handleScroll, { passive: true });

            // Setup minimap
            const minimap = document.querySelector('.minimap');
            if (minimap) {
                minimap.addEventListener('click', handleMinimapClick);
            }

            // Render minimap after a brief delay to ensure heights are measured
            setTimeout(() => {
                calculateOffsets();
                renderMinimap();
                updateMinimapViewport(content.scrollTop, content.clientHeight);
            }, 50);
        }

        function selectMessage(index, direction = 0) {
            if (allMessages.length === 0) return;

            index = Math.max(0, Math.min(index, allMessages.length - 1));
            selectedMessageIndex = index;

            // Scroll to the message position
            const msgOffset = messageOffsets[index] || 0;
            content.scrollTo({ top: Math.max(0, msgOffset - 100) });

            // Re-render to show selection (scroll handler will update visible range)
            setTimeout(() => {
                const msgEl = document.getElementById(allMessages[index].msg_id);
                if (msgEl) {
                    content.querySelectorAll('.message').forEach(m => m.classList.remove('selected'));
                    msgEl.classList.add('selected');
                }
            }, 50);
        }

        function navigateMessages(direction) {
            if (allMessages.length === 0) return;

            if (selectedMessageIndex === -1) {
                selectMessage(direction > 0 ? 0 : allMessages.length - 1, direction);
            } else {
                selectMessage(selectedMessageIndex + direction, direction);
            }
        }

        function navigateSessions(direction) {
            if (sessions.length === 0) return;

            const currentIndex = currentSession
                ? sessions.findIndex(s => s.session_id === currentSession.session_id)
                : -1;

            let newIndex;
            if (currentIndex === -1) {
                newIndex = direction > 0 ? 0 : sessions.length - 1;
            } else {
                newIndex = Math.max(0, Math.min(currentIndex + direction, sessions.length - 1));
            }

            if (newIndex !== currentIndex) {
                loadSession(sessions[newIndex].session_id);
            }
        }

        function renderSearchResults(query, results) {
            if (results.length === 0) {
                content.innerHTML = `
                    <div class="empty-state">
                        <h2>No results</h2>
                        <p>No messages found for "${escapeHtml(query)}"</p>
                    </div>
                `;
                return;
            }

            content.innerHTML = `
                <div class="search-results">
                    <h2>Search results for "${escapeHtml(query)}" (${results.length})</h2>
                    ${results.map(r => `
                        <div class="search-result" data-session="${r.session_id}" data-msg="${r.msg_id}">
                            <div class="search-result-meta">
                                <span class="badge">${r.project}</span>
                                <span>${r.role}</span>
                            </div>
                            <div>${r.snippet || escapeHtml(r.content.substring(0, 200))}</div>
                        </div>
                    `).join('')}
                </div>
            `;

            content.querySelectorAll('.search-result').forEach(item => {
                item.addEventListener('click', () => {
                    loadSession(item.dataset.session, item.dataset.msg);
                });
            });
        }

        // Load functions
        async function loadSessions() {
            sessions = await fetchSessions();
            renderSessionList();
            statusText.textContent = `${sessions.length} sessions`;
        }

        async function loadSession(id, scrollToMsg = null) {
            const session = sessions.find(s => s.session_id === id);
            if (!session) return;

            currentSession = session;
            const messages = await fetchMessages(id);
            currentSessionData = { session, messages };
            renderSession(currentSessionData);
            renderSessionList();

            startWatching(id);

            if (scrollToMsg) {
                setTimeout(() => {
                    const el = document.getElementById(scrollToMsg);
                    if (el) el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 100);
            }
        }

        async function doSearch(query) {
            if (!query.trim()) {
                if (currentSession) {
                    await loadSession(currentSession.session_id);
                } else {
                    content.innerHTML = `
                        <div class="empty-state">
                            <h2>Select a session</h2>
                            <p>Choose a session from the sidebar or search for messages</p>
                        </div>
                    `;
                }
                return;
            }

            const results = await searchMessages(query);
            renderSearchResults(query, results);
        }

        // Utilities
        function escapeHtml(text) {
            if (!text) return '';
            return text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;');
        }

        function formatContent(text) {
            if (!text) return '';
            let html = escapeHtml(text);
            html = html.replace(/```(\w*)\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>');
            html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
            html = html.replace(/\[Thinking\]\n([\s\S]*?)(?=\n\[|$)/g,
                '<div class="thinking-block"><div class="thinking-label">Thinking</div>$1</div>');
            html = html.replace(/\[(Tool|Read|Write|Edit|Bash|Glob|Grep|Task|Question|Todo List|Entering Plan Mode|Exiting Plan Mode)([^\]]*)\]([\s\S]*?)(?=\n\[|\n\n|<div|$)/g,
                '<div class="tool-block">[$1$2]$3</div>');
            return html;
        }

        function formatDate(ts) {
            if (!ts) return '';
            return new Date(ts).toLocaleDateString();
        }

        function formatTime(ts) {
            if (!ts) return '';
            return new Date(ts).toLocaleTimeString();
        }

        function formatAgentName(agent) {
            return { claude: 'Claude', codex: 'Codex' }[agent] || agent || 'Claude';
        }

        function openShortcutsModal() { shortcutsModal.classList.add('visible'); }
        function closeShortcutsModal() { shortcutsModal.classList.remove('visible'); }

        // Event handlers
        searchInput.addEventListener('input', (e) => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => doSearch(e.target.value), 300);
        });

        syncBtn.addEventListener('click', triggerSync);
        sortBtn.addEventListener('click', toggleSort);
        scrollTopBtn.addEventListener('click', () => content.scrollTo({ top: 0 }));
        shortcutsBtn.addEventListener('click', openShortcutsModal);
        modalClose.addEventListener('click', closeShortcutsModal);

        shortcutsModal.addEventListener('click', (e) => {
            if (e.target === shortcutsModal) closeShortcutsModal();
        });

        document.addEventListener('keydown', (e) => {
            const isModalOpen = shortcutsModal.classList.contains('visible');
            const isInputFocused = document.activeElement === searchInput;

            if (e.key === 'Escape') {
                if (isModalOpen) {
                    closeShortcutsModal();
                    e.preventDefault();
                } else if (isInputFocused) {
                    searchInput.value = '';
                    searchInput.blur();
                    doSearch('');
                }
                return;
            }

            if (isModalOpen) return;

            if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
                e.preventDefault();
                searchInput.focus();
                searchInput.select();
                return;
            }

            if (isInputFocused) return;

            if (e.key === 'ArrowDown' || e.key === 'j') {
                e.preventDefault();
                navigateMessages(1);
            } else if (e.key === 'ArrowUp' || e.key === 'k') {
                e.preventDefault();
                navigateMessages(-1);
            } else if (e.key === ']') {
                e.preventDefault();
                navigateSessions(1);
            } else if (e.key === '[') {
                e.preventDefault();
                navigateSessions(-1);
            } else if (e.key === 'o') {
                e.preventDefault();
                toggleSort();
            } else if (e.key === 'r') {
                e.preventDefault();
                triggerSync();
            } else if (e.key === '?') {
                e.preventDefault();
                openShortcutsModal();
            }
        });

        // Initialize
        (async () => {
            await loadSessions();
            if (sessions.length > 0) {
                await loadSession(sessions[0].session_id);
            }
        })();
    </script>
</body>
</html>
